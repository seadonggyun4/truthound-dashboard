/**
 * Schema API handlers
 */

import { http, HttpResponse, delay } from 'msw'
import { getStore, getById, getSchemaBySourceId } from '../data/store'
import { createSchema, createId } from '../factories'

const API_BASE = '/api/v1'

export const schemasHandlers = [
  // Get schema for a source
  http.get(`${API_BASE}/sources/:sourceId/schema`, async ({ params }) => {
    await delay(150)

    const sourceId = params.sourceId as string
    const source = getById(getStore().sources, sourceId)

    if (!source) {
      return HttpResponse.json(
        { detail: 'Source not found' },
        { status: 404 }
      )
    }

    const schema = getSchemaBySourceId(sourceId)

    if (!schema) {
      return HttpResponse.json({
        success: true,
        data: null,
      })
    }

    return HttpResponse.json({
      success: true,
      data: schema,
    })
  }),

  // Learn schema for a source
  http.post(`${API_BASE}/sources/:sourceId/learn`, async ({ params, request }) => {
    await delay(1000) // Simulate learning time

    const sourceId = params.sourceId as string
    const source = getById(getStore().sources, sourceId)

    if (!source) {
      return HttpResponse.json(
        { detail: 'Source not found' },
        { status: 404 }
      )
    }

    // Parse request body for learn options
    interface LearnRequest {
      infer_constraints?: boolean
      categorical_threshold?: number
      sample_size?: number
    }

    let learnOptions: LearnRequest = {}
    try {
      const body = await request.json()
      learnOptions = body as LearnRequest
    } catch {
      // Empty body is fine, use defaults
    }

    // Validate categorical_threshold if provided (1-1000)
    if (learnOptions.categorical_threshold !== undefined) {
      if (learnOptions.categorical_threshold < 1 || learnOptions.categorical_threshold > 1000) {
        return HttpResponse.json(
          { detail: 'categorical_threshold must be between 1 and 1000' },
          { status: 422 }
        )
      }
    }

    // Validate sample_size if provided (>= 100)
    if (learnOptions.sample_size !== undefined) {
      if (learnOptions.sample_size < 100) {
        return HttpResponse.json(
          { detail: 'sample_size must be at least 100' },
          { status: 422 }
        )
      }
    }

    // Create schema (categorical_threshold affects how many enum constraints are inferred)
    // In mock, we simulate this by varying column count slightly based on options
    const columnCount = learnOptions.sample_size
      ? Math.min(20, Math.max(5, Math.floor(learnOptions.sample_size / 1000)))
      : undefined

    // Create or update schema
    const schema = createSchema({
      id: createId(),
      sourceId,
      columnCount,
    })

    getStore().schemas.set(sourceId, schema)

    // Update source's has_schema flag
    const sources = getStore().sources
    sources.set(sourceId, { ...source, has_schema: true })

    return HttpResponse.json({
      success: true,
      data: schema,
    })
  }),

  // Update schema
  http.put(`${API_BASE}/sources/:sourceId/schema`, async ({ params, request }) => {
    await delay(300)

    const sourceId = params.sourceId as string
    const source = getById(getStore().sources, sourceId)

    if (!source) {
      return HttpResponse.json(
        { detail: 'Source not found' },
        { status: 404 }
      )
    }

    let body: { schema_yaml: string }

    try {
      body = await request.json() as typeof body
    } catch {
      return HttpResponse.json(
        { detail: 'Invalid JSON in request body' },
        { status: 400 }
      )
    }

    // Validate schema_yaml is not empty
    if (!body.schema_yaml || body.schema_yaml.trim() === '') {
      return HttpResponse.json(
        { detail: 'schema_yaml cannot be empty' },
        { status: 400 }
      )
    }

    const existingSchema = getSchemaBySourceId(sourceId)

    // If no existing schema, create a new one with the provided YAML
    // The schema_json will be generated by createSchema and we update YAML
    const baseSchema = existingSchema ?? createSchema({ sourceId })

    const updatedSchema = {
      ...baseSchema,
      schema_yaml: body.schema_yaml,
      // Keep existing schema_json if available, as we can't easily parse YAML in browser
      // In real API, this would be parsed and synced
      updated_at: new Date().toISOString(),
    }

    getStore().schemas.set(sourceId, updatedSchema)

    // Update source's has_schema flag if it wasn't set
    const sources = getStore().sources
    const existingSource = sources.get(sourceId)
    if (existingSource && !existingSource.has_schema) {
      sources.set(sourceId, { ...existingSource, has_schema: true })
    }

    return HttpResponse.json({
      success: true,
      data: updatedSchema,
    })
  }),
]
