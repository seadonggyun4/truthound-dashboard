/**
 * Glossary factory - generates realistic business glossary mock data
 */

import type {
  GlossaryTerm,
  GlossaryCategory,
  TermRelationship,
  TermHistory,
  GlossaryTermSummary,
} from '@/api/client'
import {
  createId,
  createTimestamp,
  createRecentTimestamp,
  randomChoice,
  faker,
} from './base'

// ============================================================================
// Categories
// ============================================================================

const CATEGORY_NAMES = [
  'Customer Data',
  'Financial Metrics',
  'Product Information',
  'Marketing Terms',
  'Sales Metrics',
  'Operations',
  'HR Terms',
  'Technical Terms',
  'Compliance',
  'Analytics',
]

export interface CategoryFactoryOptions {
  id?: string
  name?: string
  description?: string
  parentId?: string
}

export function createGlossaryCategory(options: CategoryFactoryOptions = {}): GlossaryCategory {
  const now = new Date().toISOString()
  return {
    id: options.id ?? createId(),
    name: options.name ?? randomChoice(CATEGORY_NAMES) + ` (${faker.string.alphanumeric(3)})`,
    description: options.description ?? faker.lorem.sentence(),
    parent_id: options.parentId,
    created_at: createTimestamp(faker.number.int({ min: 30, max: 365 })),
    updated_at: now,
    children: [],
  }
}

export function createGlossaryCategories(count: number): GlossaryCategory[] {
  return Array.from({ length: count }, () => createGlossaryCategory())
}

// ============================================================================
// Terms
// ============================================================================

const TERM_DEFINITIONS: Record<string, string> = {
  'Customer Lifetime Value': 'The total revenue a business can expect from a single customer account throughout the business relationship.',
  'Churn Rate': 'The percentage of customers who stop using a product or service during a given time period.',
  'Net Promoter Score': 'A metric that measures customer experience and predicts business growth.',
  'Average Order Value': 'The average dollar amount spent each time a customer places an order.',
  'Conversion Rate': 'The percentage of users who take a desired action.',
  'Active User': 'A user who has engaged with the product within a specified time period.',
  'Revenue': 'The total amount of income generated by the sale of goods or services.',
  'Gross Margin': 'The difference between revenue and cost of goods sold, divided by revenue.',
  'Lead': 'A potential customer who has shown interest in a product or service.',
  'Opportunity': 'A qualified lead with a reasonable chance of becoming a customer.',
  'Pipeline': 'The total value of all active sales opportunities.',
  'SKU': 'Stock Keeping Unit - a unique identifier for a product.',
  'Inventory Turnover': 'How many times inventory is sold and replaced over a period.',
  'Customer Acquisition Cost': 'The cost associated with convincing a customer to buy a product or service.',
  'Return on Investment': 'A measure of the profitability of an investment.',
}

const TERM_NAMES = Object.keys(TERM_DEFINITIONS)

const TERM_STATUSES: Array<'draft' | 'approved' | 'deprecated'> = ['draft', 'approved', 'deprecated']

export interface TermFactoryOptions {
  id?: string
  name?: string
  definition?: string
  categoryId?: string
  status?: 'draft' | 'approved' | 'deprecated'
  ownerId?: string
}

export function createGlossaryTerm(options: TermFactoryOptions = {}): GlossaryTerm {
  const name = options.name ?? randomChoice(TERM_NAMES) + ` (${faker.string.alphanumeric(3)})`
  const baseName = name.split(' (')[0]
  const definition = options.definition ?? TERM_DEFINITIONS[baseName] ?? faker.lorem.sentences(2)

  return {
    id: options.id ?? createId(),
    name,
    definition,
    category_id: options.categoryId,
    status: options.status ?? randomChoice(TERM_STATUSES),
    owner_id: options.ownerId ?? faker.person.fullName(),
    created_at: createTimestamp(faker.number.int({ min: 7, max: 180 })),
    updated_at: createRecentTimestamp(),
    synonyms: [],
    related_terms: [],
  }
}

export function createGlossaryTerms(count: number): GlossaryTerm[] {
  return Array.from({ length: count }, () => createGlossaryTerm())
}

export function createTermSummary(term: GlossaryTerm): GlossaryTermSummary {
  return {
    id: term.id,
    name: term.name,
    definition: term.definition,
  }
}

// ============================================================================
// Relationships
// ============================================================================

const RELATIONSHIP_TYPES: Array<'synonym' | 'related' | 'parent' | 'child'> = [
  'synonym',
  'related',
  'parent',
  'child',
]

export interface RelationshipFactoryOptions {
  id?: string
  sourceTermId?: string
  targetTermId?: string
  relationshipType?: 'synonym' | 'related' | 'parent' | 'child'
  sourceTerm?: GlossaryTermSummary
  targetTerm?: GlossaryTermSummary
}

export function createTermRelationship(options: RelationshipFactoryOptions = {}): TermRelationship {
  const sourceId = options.sourceTermId ?? createId()
  const targetId = options.targetTermId ?? createId()

  return {
    id: options.id ?? createId(),
    source_term_id: sourceId,
    target_term_id: targetId,
    relationship_type: options.relationshipType ?? randomChoice(RELATIONSHIP_TYPES),
    created_at: createTimestamp(faker.number.int({ min: 1, max: 90 })),
    source_term: options.sourceTerm ?? {
      id: sourceId,
      name: randomChoice(TERM_NAMES),
      definition: faker.lorem.sentence(),
    },
    target_term: options.targetTerm ?? {
      id: targetId,
      name: randomChoice(TERM_NAMES),
      definition: faker.lorem.sentence(),
    },
  }
}

// ============================================================================
// History
// ============================================================================

const FIELD_NAMES = ['name', 'definition', 'status', 'category_id', 'owner_id']

export interface HistoryFactoryOptions {
  id?: string
  termId?: string
  fieldName?: string
  oldValue?: string
  newValue?: string
  changedBy?: string
}

export function createTermHistory(options: HistoryFactoryOptions = {}): TermHistory {
  const fieldName = options.fieldName ?? randomChoice(FIELD_NAMES)
  let oldValue = options.oldValue
  let newValue = options.newValue

  if (!oldValue || !newValue) {
    switch (fieldName) {
      case 'name':
        oldValue = oldValue ?? faker.commerce.productName()
        newValue = newValue ?? faker.commerce.productName()
        break
      case 'definition':
        oldValue = oldValue ?? faker.lorem.sentence()
        newValue = newValue ?? faker.lorem.sentence()
        break
      case 'status':
        oldValue = oldValue ?? randomChoice(['draft', 'approved'])
        newValue = newValue ?? randomChoice(['approved', 'deprecated'])
        break
      case 'owner_id':
        oldValue = oldValue ?? faker.person.fullName()
        newValue = newValue ?? faker.person.fullName()
        break
      default:
        oldValue = oldValue ?? ''
        newValue = newValue ?? ''
    }
  }

  return {
    id: options.id ?? createId(),
    term_id: options.termId ?? createId(),
    field_name: fieldName,
    old_value: oldValue,
    new_value: newValue,
    changed_by: options.changedBy ?? faker.person.fullName(),
    changed_at: createRecentTimestamp(),
  }
}

export function createTermHistories(termId: string, count: number): TermHistory[] {
  return Array.from({ length: count }, () => createTermHistory({ termId }))
}

// ============================================================================
// Diverse Data Sets
// ============================================================================

export function createDiverseCategories(): GlossaryCategory[] {
  return CATEGORY_NAMES.slice(0, 6).map((name) => createGlossaryCategory({ name }))
}

export function createDiverseTerms(categories: GlossaryCategory[]): GlossaryTerm[] {
  const terms: GlossaryTerm[] = []
  const categoryIds = categories.map((c) => c.id)

  // Create terms with different statuses
  TERM_STATUSES.forEach((status) => {
    terms.push(
      createGlossaryTerm({
        status,
        categoryId: randomChoice(categoryIds),
      })
    )
  })

  // Create terms in each category
  categoryIds.forEach((categoryId) => {
    terms.push(createGlossaryTerm({ categoryId }))
  })

  // Add more random terms
  for (let i = 0; i < 10; i++) {
    terms.push(
      createGlossaryTerm({
        categoryId: faker.datatype.boolean(0.7) ? randomChoice(categoryIds) : undefined,
      })
    )
  }

  return terms
}

export function createTermsWithRelationships(
  terms: GlossaryTerm[]
): { terms: GlossaryTerm[]; relationships: TermRelationship[] } {
  const relationships: TermRelationship[] = []

  // Create synonym pairs
  for (let i = 0; i < Math.min(3, terms.length - 1); i++) {
    const source = terms[i]
    const target = terms[i + 1]
    relationships.push(
      createTermRelationship({
        sourceTermId: source.id,
        targetTermId: target.id,
        relationshipType: 'synonym',
        sourceTerm: createTermSummary(source),
        targetTerm: createTermSummary(target),
      })
    )
  }

  // Create related term pairs
  for (let i = 0; i < Math.min(5, terms.length - 2); i++) {
    const source = terms[i]
    const target = terms[terms.length - 1 - i]
    if (source.id !== target.id) {
      relationships.push(
        createTermRelationship({
          sourceTermId: source.id,
          targetTermId: target.id,
          relationshipType: 'related',
          sourceTerm: createTermSummary(source),
          targetTerm: createTermSummary(target),
        })
      )
    }
  }

  // Update terms with relationship data
  const updatedTerms = terms.map((term) => {
    const synonyms = relationships
      .filter((r) => r.relationship_type === 'synonym' && r.source_term_id === term.id)
      .map((r) => r.target_term)
    const relatedTerms = relationships
      .filter((r) => r.relationship_type === 'related' && r.source_term_id === term.id)
      .map((r) => r.target_term)

    return { ...term, synonyms, related_terms: relatedTerms }
  })

  return { terms: updatedTerms, relationships }
}
